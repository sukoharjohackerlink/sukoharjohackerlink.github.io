[
  
  {
    "title": "Pwnable 2025",
    "url": "/posts/pwnable-2025/",
    "categories": "",
    "tags": "",
    "date": "2025-11-14 00:00:00 +0700",
    "content": " "
  },
  
  {
    "title": "Meta4Sec 2025‚Äì Crypto",
    "url": "/posts/Meta4Sec-2025/",
    "categories": "National Event, Meta4Sec 2025, ctf",
    "tags": "crypto",
    "date": "2025-08-02 00:00:00 +0700",
    "content": "   Meta4Sec 2025 ‚Äì Crypto Writeup     Writeup from the Meta4Sec CTF Cryptography challenge that I‚Äôve worked on   Thank you for taking the time and effort to solve the cryptography challenge I created. I truly appreciate the thought, strategies, and dedication you put into working through it. I hope this challenge provided you with valuable experience and insight into the world of cryptography. üíªüîê    üîê Crypto  üîπ Challenge: 0    Description: -   Attachments: chall_0.zip   Solution Steps:   üß© Challenge Overview  We are provided with a zip archive. After extracting it, we get the following files:  flag.txt  output_test.txt  readme.md  test.txt   üìÑ readme.md  A mysterious message has been intercepted, and according to analysts, it appears to be encrypted with an unusual twist on a traditional cipher.  Luckily, we have a sample of both the plaintext and its corresponding ciphertext, which seems to be encrypted using the same method as the flag.  Your task is to: 1. Identify the encryption pattern by comparing the known plaintext and ciphertext. 2. Use this pattern to decrypt the flag in `flag.txt`.  ===[ Files ]===  - test.txt            # known plaintext - output_test.txt     # corresponding ciphertext - flag.txt            # encrypted flag  ===[ Objective ]===  Retrieve the original flag from `flag.txt`.  Flag format: `Meta4Sec{...}`  Brute-forcing isn't required to solve this, but you‚Äôre welcome to try. A logical approach and familiarity with classic ciphers will be more effective.  Good luck!     üéØ Task Summary  Based on the information in readme.md, the main objective is to analyze the encryption used in test.txt and output_test.txt, and then apply the same logic to decrypt flag.txt.    üîç Sample Analysis  From output_test.txt: Sheajra Shaal suat bkeunt einskpri taeurt dmaal sheajra dna mhais saendaehr ahdaal einskpri mneankgagnu aalmgtoir   From test.txt: Sejarah Salah satu bentuk enkripsi tertua dalam sejarah dan masih sederhana adalah enkripsi menggunakan algoritma   Let‚Äôs examine the encryption of the word Sejarah ~&gt; Sheajra.                 Index       Original       Encrypted                       0       S       S                 1       e       h                 2       j       e                 3       a       a                 4       r       j                 5       a       r                 6       h       a           We observe the following transformation:    index[0] stays the same ~&gt; S   index[1] becomes index[6]   index[2] becomes index[1]   index[3] becomes index[5]   index[4] becomes index[2]   index[5] becomes index[4]   index[6] becomes index[3]   bentuk ~&gt; bkeunt                 Index       Original       Encrypted                       0       b       b                 1       e       k                 2       n       e                 3       t       u                 4       u       n                 5       k       t              index[0] stays the same ‚Üí b   index[1] becomes index[5]   index[2] becomes index[1]   index[3] becomes index[5]   index[4] becomes index[2]   index[5] becomes index[4]   This suggests a fixed permutation pattern This insight gives us a solid base to reverse the process and decrypt the flag.     solver.py    encode(s:str) -&gt; str:     result = []     n = len(s)     for i in range(n // 2):         result.append(s[i])         result.append(s[n - 1 - i])     if n % 2 == 1:         result.append(s[n // 2])     return ''.join(result)  def decode(s:str) -&gt; str:     n = len(s)     result = [''] * n     left = 0     right = n - 1     idx = 0     for i in range(n // 2):         result[left] = s[idx]         result[right] = s[idx + 1]         idx += 2         left += 1         right -= 1     if n % 2 == 1:         result[left] = s[idx]     return ''.join(result)   with open('flag.txt','r') as f:     enc = f.read().split() decrypted = [] for j in enc:     decrypted.append(decode(j))  print(' '.join(decrypted))      Flag: Meta4Sec{sajjjaddddkunnnn_absoluteeee_cineemaaaaaa_202cb962ac}     üîπ Challenge: 1    Description: -   Attachments:  chall_zip   Solution Steps:   üîê Overview  This challenge script implements RSA encryption using a custom large-prime generation method. The encryption process introduces several cryptographic weaknesses that make the ciphertext recoverable.    üß™ Prime Generation Logic  def generate_large_prime_product():     p = getPrime(512)     n = 1     phi = 1     primes = []      while True:         primes.append(p)         n *= p         phi *= (p - 1)         if n.bit_length() &gt;= 8192:             break         p = nextprime(nextprime(p))      return n, primes, phi, p      This function generates multiple 512-bit primes and multiplies them until the result (n) is at least 8192 bits long.   The primes are generated using nextprime(nextprime(p)), meaning each new prime is very close to the previous one.   Because these primes are closely spaced, the modulus n becomes vulnerable to root-based factorization techniques and then go back into previous prime until the result of  gcd prime and N less than 512 bit length.     üß¨ RSA Key Generation Logic  def get_valid_prime_update(n):     return nextprime(n)  def generate_rsa_keys(p, e=65537):     q = getPrime(16)     n = p * q     phi = (p - 1) * (q - 1)     d = inverse(e, phi)     private_key = RSA.construct((n, e, d, p, q))     public_key = private_key.publickey()     return private_key, public_key      After the initial modulus is constructed, the program updates the prime using nextprime(n) and treats this as the new p.   A new small prime q is generated using getPrime(16), which results in a 16-bit value.   Because q is so small, it can be brute-forced easily by trying all values in the range [1, 65536].     ‚ö†Ô∏è Vulnerability Summary     The first modulus n is built from many closely spaced 512-bit primes. These can be factored using numerical root techniques since the primes are near each other.   The updated prime p is just nextprime(n), which is predictable.   The second prime q is only 16 bits, making it trivial to brute-force.   These combined weaknesses make it possible to reconstruct the private RSA key and recover the plaintext from public.pem and the encrypted file.     üß© Exploitation Strategy     Factor the initial 8192-bit modulus using numerical methods that exploit closely spaced primes.   Compute p = nextprime(n) as used in the second phase.   Brute-force all possible 16-bit q values (‚â§ 65536) to find the correct one.   Rebuild the full private key using p and q.   Decrypt the encrypted chunks and recover the original ciphertext.     üìú Solver  # === IMPORTS === import base64 import time from math import gcd  from sympy import nextprime from gmpy2 import iroot from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_OAEP from Crypto.Util.number import (     getPrime, inverse, bytes_to_long, long_to_bytes, isPrime )  # === HELPER FUNCTIONS ===  def prevprime(n):     \"\"\"Find previous prime before n.\"\"\"     n -= 1     while n &gt; 1:         if isPrime(n):             return n         n -= 1     return None  # Shouldn't happen for n &gt; 2  def generate_large_prime_product(p, n_candidate, e=65537):     \"\"\"Generate RSA modulus and private exponent from base prime `p`.\"\"\"     n = 1     phi = 1     primes = []      while True:         primes.append(p)         n *= p         phi *= (p - 1)         if n.bit_length() &gt;= 8192:             break         p = nextprime(nextprime(p))      if n in n_candidate:         d = inverse(e, phi)         return n, e, d      return None, None, None  def decrypt(p, q, encrypted, e=65537):     \"\"\"Decrypt ciphertext using reconstructed RSA private key.\"\"\"     n = p * q     phi = (p - 1) * (q - 1)     d = inverse(e, phi)      private_key = RSA.construct((n, e, d, p, q))     public_key = private_key.publickey()      cipher_decrypt = PKCS1_OAEP.new(private_key)      key_size = public_key.size_in_bytes()     chunk_size = key_size  # ciphertext chunk size      decrypted_data = b\"\"     for i in range(0, len(encrypted), chunk_size):         chunk = encrypted[i:i + chunk_size]         decrypted_data += cipher_decrypt.decrypt(chunk)      return decrypted_data  def find_factor_1(x):     \"\"\"Brute-force factor using small values.\"\"\"     for i in range(32767, 65537):         if gcd(x, i) &lt; 3000:             continue         p = i         q = x // i         return p, q  # === MAIN PROGRAM ===  if __name__ == \"__main__\":     # Load public key     with open(\"public.pem\", \"rb\") as f:         public_key = RSA.import_key(f.read())      # Load encrypted file     with open(\"encrypted\", \"rb\") as f:         ct = f.read()      n = public_key.n     e = public_key.e      # Factor n (rough guess)     p, q = find_factor_1(n)      # Decrypt with small p and q     ct_2 = bytes_to_long(decrypt(p, q, ct))      # Build candidate list near q     n_candidate = [q - i for i in range(100000)]      # Try root extraction to find 512-bit base     to_pr = []     for j in range(1, 50):         n_pr = iroot(q, j)[0]         if n_pr.bit_length() == 512:             to_pr.append(n_pr)      prim = to_pr[0]     sav = []      # Start prime search     start_time = time.time()     while True:         if time.time() - start_time &gt; 10:             break          if isPrime(prim):             found = False             for N in n_candidate:                 if gcd(prim, N) != 1:                     if prim not in sav:                         sav.append(prim)                         print(f\"[+] Found: {prim}\")                     found = True                     break             prim = prevprime(prevprime(prim)) if found else prevprime(prim)         else:             prim = prevprime(prim)      print(\"Saved primes:\", sav)     print(\"Last checked prime:\", prim)      # Generate RSA params using last saved prime     f_pr = sav[-1]     n, e, d = generate_large_prime_product(f_pr, n_candidate)      # Decrypt the actual flag     if n and d:         flag = long_to_bytes(pow(ct_2, d, n))         print(flag.decode())     else:         print(\"Failed to generate valid RSA parameters.\")  ‚úÖ Conclusion  This encryption mechanism is flawed due to:     Use of many closely spaced primes to generate a large modulus.   Use of a predictable updated prime via nextprime(n).   Use of a weak 16-bit prime for RSA key generation.   These flaws break RSA‚Äôs security assumptions and allow full decryption of the encrypted flag.       Flag: Meta4Sec{l0r3m_1p5um_d0l0r_517_4m37_de6e5}          ‚ÄúCapture The Flag is not just a game. It‚Äôs a journey to mastering cybersecurity.‚Äù #HappyHacking üîê  "
  },
  
  {
    "title": "UIUCTF 2025‚Äì CTF Writeup",
    "url": "/posts/UIUCTF-2025/",
    "categories": "International Event, UIUCTF 2025, ctf",
    "tags": "ctftime, pwn, crypto, reversing",
    "date": "2025-07-29 00:00:00 +0700",
    "content": "   UIUCTF 2025‚Äì CTF Writeup     Writeup from the UIUCTF 2025 CTF event.     üîê Crypto  üîπ the_shortest_crypto_chal    Description: I‚Äôve designed the shortest crypto challenge - can you find the flag?   Solution Steps:   from Crypto.Cipher import AES from hashlib import md5 from secret import a,b,c,d, FLAG  assert a**4 + b**4 == c**4 + d**4 + 17 and max(a,b,c,d) &lt; 2e4 and AES.new( f\"{a*b*c*d}\".zfill(16).encode() , AES.MODE_ECB).encrypt(FLAG).hex() == \"41593455378fed8c3bd344827a193bde7ec2044a3f7a3ca6fb77448e9de55155\"   #include &lt;iostream&gt; #include &lt;unordered_map&gt; #include &lt;vector&gt; #include &lt;cmath&gt;  using namespace std;  int main() {     const int LIMIT = 1000;      unordered_map&lt;long long, vector&lt;pair&lt;int, int&gt;&gt;&gt; rhs_map;      // Step 1: Precompute c^4 + d^4 + 17     for (int c = 0; c &lt; LIMIT; ++c) {         long long c4 = (long long)c * c * c * c;         for (int d = c; d &lt; LIMIT; ++d) {             long long d4 = (long long)d * d * d * d;             long long rhs = c4 + d4 + 17;             rhs_map[rhs].emplace_back(c, d);         }     }      // Step 2: For each a^4 + b^4, check if it exists in rhs_map     for (int a = 0; a &lt; LIMIT; ++a) {         long long a4 = (long long)a * a * a * a;         for (int b = a; b &lt; LIMIT; ++b) {             long long b4 = (long long)b * b * b * b;             long long lhs = a4 + b4;             if (rhs_map.find(lhs) != rhs_map.end()) {                 for (auto [c, d] : rhs_map[lhs]) {                     cout &lt;&lt; \"‚úÖ Found: a=\" &lt;&lt; a &lt;&lt; \" b=\" &lt;&lt; b                          &lt;&lt; \" c=\" &lt;&lt; c &lt;&lt; \" d=\" &lt;&lt; d &lt;&lt; endl;                 }             }         }     }      return 0; }   a=264 b=651 c=530 d=570 from hashlib import md5 keyy = a*b*c*d encr = AES.new(str(keyy).zfill(16).encode(),AES.MODE_ECB) ct = bytes.fromhex('41593455378fed8c3bd344827a193bde7ec2044a3f7a3ca6fb77448e9de55155') print(encr.decrypt(ct))      Flag: uiuctf{D1oPh4nTine__Destr0yer__}     üîπ symettric    Description: I‚Äôm using four primes to encrypt my flag, so I‚Äôm only giving you three hints - can you decrypt the flag?   Solution Steps:   from Crypto.Util.number import * from secret import FLAG  p, q, r, s = [getPrime(512) for _ in \"1234\"]  print(f\"h1 = {p + q + r + s}\") print(f\"h2 = {p**2 + q**2 + r**2 + s**2}\") print(f\"h3 = {p**3 + q**3 + r**3 + s**3}\")  N = p*q*r*s print(f\"N = {N}\") pt = bytes_to_long(FLAG) ct = pow(pt, 65537, N) print(f\"ct = {ct}\")  #h1 = 44626154099651354925697068610752642661842459492769931945027538340211738148995902544351457443643808803963130274930824732652561687395268828472477422919262224 #h2 = 516671113554555861164166966331322883848052630063409185414998284127910160310316421085219788291486248715029393774584960034375836715001130337767354512063372620828300201147366138270597133744747341658011663632381219284289144790858167258162656417236910634201286428763727072739569460623482985066956478781223378673732 #h3 = 6147718474663450187001867904227777991349731066494841442199681943204194617136760567222545181562592364728655444222576167723225771866335920325045525027985716792468801076590684892140052786942251780392395274059384743594570343510311801194684613435002073956759521242578078411431891501758484581445964234548107005826532945720412531638919892681259687552977883437895032963223761216846303917338652743754915155934118353066174102436448393348040719582422022713292561416343278608 #N = 14184841414933523698606245433393907034474143715949896731683874356940146602876788990832087413915033843120975580859113356518777762025417525571528638829956003882418585702756644491932279294535883798799580861254646149745925137179207140600356428758736111639677698862407787386573263961111978517446397007747429416079059195916290615125084899002162504424765939524455434579218079962808920072946861658695379491917567048202142417165204141307476222251547098848515065051745905180788313450494477967398727631152936238366581978379130450660235139256967936160718128731512409111209840405772933034600016694225294481603355934917366484109057 #ct = 720607330561370237459911161481490697044029472780348552630924063963226757984368356580217337982783395620115957442082471977614781910209933696251479615689667675958354681196823652299435457532944189300223816303315625302472302494905575910600277892375951366031061219173465155686586206246661009612156094695841741309002508535764511343569015518587247600796520847856011377777228749182958947015029731456117404560626347774985507275302882865400315045173501559082431672490227728580592379740508214726249635835834752208899970446910850569489282065524329936561486377823093465841715608716032843259935185417766702677708267102415636848129   h1 = 44626154099651354925697068610752642661842459492769931945027538340211738148995902544351457443643808803963130274930824732652561687395268828472477422919262224 h2 = 516671113554555861164166966331322883848052630063409185414998284127910160310316421085219788291486248715029393774584960034375836715001130337767354512063372620828300201147366138270597133744747341658011663632381219284289144790858167258162656417236910634201286428763727072739569460623482985066956478781223378673732 h3 = 6147718474663450187001867904227777991349731066494841442199681943204194617136760567222545181562592364728655444222576167723225771866335920325045525027985716792468801076590684892140052786942251780392395274059384743594570343510311801194684613435002073956759521242578078411431891501758484581445964234548107005826532945720412531638919892681259687552977883437895032963223761216846303917338652743754915155934118353066174102436448393348040719582422022713292561416343278608 N = 14184841414933523698606245433393907034474143715949896731683874356940146602876788990832087413915033843120975580859113356518777762025417525571528638829956003882418585702756644491932279294535883798799580861254646149745925137179207140600356428758736111639677698862407787386573263961111978517446397007747429416079059195916290615125084899002162504424765939524455434579218079962808920072946861658695379491917567048202142417165204141307476222251547098848515065051745905180788313450494477967398727631152936238366581978379130450660235139256967936160718128731512409111209840405772933034600016694225294481603355934917366484109057 ct = 720607330561370237459911161481490697044029472780348552630924063963226757984368356580217337982783395620115957442082471977614781910209933696251479615689667675958354681196823652299435457532944189300223816303315625302472302494905575910600277892375951366031061219173465155686586206246661009612156094695841741309002508535764511343569015518587247600796520847856011377777228749182958947015029731456117404560626347774985507275302882865400315045173501559082431672490227728580592379740508214726249635835834752208899970446910850569489282065524329936561486377823093465841715608716032843259935185417766702677708267102415636848129  from sympy import symbols, solve, Rational, simplify, expand from Crypto.Util.number import inverse,long_to_bytes  # Newton identities e1 = h1 e2 = Rational(h1**2 - h2, 2) e3 = Rational(h1**3 - 3*h1*h2 + 2*h3, 6) e4 = N  print(\"e1 =\", e1) print(\"e2 =\", e2) print(\"e3 =\", e3) print(\"e4 =\", e4)  # Construct polynomial x = symbols('x') poly = x**4 - e1*x**3 + e2*x**2 - e3*x + e4 print(\"Polynomial:\") print(simplify(poly))  # Solve for roots roots = solve(poly, x) print(\"Roots (p, q, r, s):\") print(roots)  p,q,r,s =roots print(p*q*r*s==N) print(f\"\"\" {p=} {q=} {r=} {s=} \"\"\")  phi_n = 1 for i in roots: \tphi_n *=(i-1) d = inverse(65537,int(phi_n)) print(long_to_bytes(pow(ct,d,N)).decode('latin-1'))      Flag: uiuctf{5yMmeTRiC_P0lyS_FoRM_A_B4S15}     üîπ too-many-primes    Description: Normal RSA uses two primes - that‚Äôs too few in my opinion, so I‚Äôve added some more.   Solution Steps:   Flag:     üîπback-to-roots    Description: I don‚Äôt think you can predict my secret number from just its square root - can you prove me wrong?   Solution Steps:   idk what‚Äôs goin on here  from random import randint from decimal import Decimal, getcontext from hashlib import md5  from Crypto.Cipher import AES from Crypto.Util.Padding import pad  from secret import FLAG  K = randint(10**10, 10**11) print('K', K) leak = int( str( Decimal(K).sqrt() ).split('.')[-1] )  print(f\"leak = {leak}\") ct = AES.new( \tmd5(f\"{K}\".encode()).digest(), \tAES.MODE_ECB ).encrypt(pad(FLAG, 16))  print(f\"ct = {ct.hex()}\") #leak = 4336282047950153046404 #ct = 7863c63a4bb2c782eb67f32928a1deceaee0259d096b192976615fba644558b2ef62e48740f7f28da587846a81697745   from decimal import Decimal, getcontext from hashlib import md5 from tqdm import tqdm from Crypto.Cipher import AES from Crypto.Util.Padding import pad  leak = 4336282047950153046404 for i in tqdm(range(99999,999999)): \ta = float(str(i)+'.'+str(leak)) \tK = int(a**2) \tct = bytes.fromhex(\"7863c63a4bb2c782eb67f32928a1deceaee0259d096b192976615fba644558b2ef62e48740f7f28da587846a81697745\") \tde = AES.new(md5(f\"{K}\".encode()).digest(),AES.MODE_ECB) \tif b'uiuctf' in de.decrypt(ct): \t        print(de.decrypt(ct),K) \t        break     Flag: uiuctf{SQu4Re_Ro0T5_AR3nT_R4nD0M}     üí£ Pwn  üîπ QAS    Description: Since we are so behind on adopting ‚ÄúAI‚Äù, corporate has decided to pivot to ‚Äúquantum‚Äù. They mandated we ‚Äúquantumfy‚Äù our tech stack. Please review our latest authentication protocol. ncat --ssl qas.chal.uiuc.tf 1337   Attachments: Handout.tar.gz   Solution Steps:   #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;time.h&gt;  // Quantum-grade type definitions for maximum security typedef int not_int_small; typedef short int_small; typedef int not_int_big; typedef not_int_small int_big; typedef unsigned char quantum_byte; typedef quantum_byte* quantum_ptr;  // Advanced authentication structures typedef struct {     not_int_big val; } PASSWORD_QUANTUM;  typedef struct {     int_small val;     quantum_byte padding[2];     quantum_byte checksum;     quantum_byte reserved; } INPUT_QUANTUM;  // Memory-aligned structure for optimal quantum processing struct __attribute__((packed)) quantum_data_s {     INPUT_QUANTUM input;     PASSWORD_QUANTUM password;     quantum_byte entropy_pool[8];     quantum_byte quantum_state[16]; };  typedef struct quantum_data_s quantum_data_t;  // Quantum random number generator (patent pending) static inline quantum_byte generate_quantum_entropy() {     static quantum_byte seed = 0x42;     seed = ((seed &lt;&lt; 3) ^ (seed &gt;&gt; 5)) + 0x7f;     return seed; }  // Initialize quantum security subsystem void init_quantum_security(quantum_data_t* qdata) {     for (int i = 0; i &lt; 8; i++) {         qdata-&gt;entropy_pool[i] = generate_quantum_entropy();     }      // Initialize quantum state with pseudo-random values     for (int i = 0; i &lt; 16; i++) {         qdata-&gt;quantum_state[i] = (quantum_byte)(i * 0x11 + 0x33);     }      qdata-&gt;input.padding[0] = 0;     qdata-&gt;input.padding[1] = 0; }  // Quantum hash function (revolutionary technology) not_int_big quantum_hash(INPUT_QUANTUM input, quantum_byte* entropy) {     int_small input_val = input.val;     not_int_big hash = input_val;      // Apply quantum transformation matrix     hash ^= (entropy[0] &lt;&lt; 8) | entropy[1];     hash ^= (entropy[2] &lt;&lt; 4) | (entropy[3] &gt;&gt; 4);     hash += (entropy[4] * entropy[5]) &amp; 0xff;     hash ^= entropy[6] ^ entropy[7];     hash |= 0xeee;     hash ^= input.padding[0] &lt;&lt; 8 | input.padding[1];      return hash; }  // Decrypt the victory condition void access_granted() {     printf(\"Quantum authentication successful!\\n\");     printf(\"Accessing secured vault...\\n\");      FILE *fp = fopen(\"flag.txt\", \"r\");     if (fp == NULL) {         printf(\"Error: Quantum vault is offline\\n\");         printf(\"Please contact the quantum administrator.\\n\");         return;     }      char flag[100];     if (fgets(flag, sizeof(flag), fp) != NULL) {         printf(\"CLASSIFIED FLAG: %s\\n\", flag);     } else {         printf(\"Error: Quantum decryption failed\\n\");         printf(\"Please contact the quantum administrator.\\n\");     }     fclose(fp); }  int main() {     quantum_data_t qdata;      setvbuf(stdout, NULL, _IONBF, 0);     setvbuf(stdin, NULL, _IONBF, 0);     setvbuf(stderr, NULL, _IONBF, 0);      // Initialize quantum security subsystem     init_quantum_security(&amp;qdata);      // Set quantum password (TODO: implement proper quantum key derivation)     qdata.password.val = 0x555;      printf(\"=== QUANTUM AUTHENTICATION SYSTEM v2.7.3 ===\\n\");     printf(\"Initializing quantum security protocols...\\n\");      // Simulate quantum initialization delay     for (volatile int i = 0; i &lt; 100000; i++) { /* quantum processing */ }      printf(\"Quantum entropy generated. System ready.\\n\");     printf(\"Please enter your quantum authentication code: \");      // Read user input     if (scanf(\"%d\", (int*)&amp;qdata.input.val) != 1) {         printf(\"Invalid quantum input format!\\n\");         return 1;     }      // Calculate input checksum for integrity     qdata.input.checksum = (quantum_byte)(qdata.input.val &amp; 0xff);      // Apply quantum hash transformation     not_int_big hashed_input = quantum_hash(qdata.input, qdata.entropy_pool);      printf(\"Quantum hash computed: 0x%x\\n\", hashed_input);      // Verify quantum authentication     if (hashed_input == qdata.password.val) {         access_granted();     } else {         printf(\"Quantum authentication failed!\\n\");         printf(\"Access denied. Incident logged.\\n\");     }      return 0; }   from pwn import *  context.log_level = 'debug'  p = process('./chal') import struct  target = 0x555  def gen_entropy():     seed = 0x42     pool = []     for _ in range(8):         seed = ((seed &lt;&lt; 3) ^ (seed &gt;&gt; 5)) + 0x7f         seed &amp;= 0xff         pool.append(seed)     return pool  entropy = gen_entropy()   for val in range(0x10000):     for pad0 in range(0x100):         for pad1 in range(0x100):             hash = val             hash ^= (entropy[0] &lt;&lt; 8) | entropy[1]             hash ^= (entropy[2] &lt;&lt; 4) | (entropy[3] &gt;&gt; 4)             hash += (entropy[4] * entropy[5]) &amp; 0xff             hash ^= entropy[6] ^ entropy[7]             hash |= 0xeee             hash ^= (pad0 &lt;&lt; 8) | pad1              if hash != target:                 continue             full_input = struct.unpack(\"&lt;i\", struct.pack(\"&lt;HBB\", val, pad0, pad1))[0]             print(f\"FOUND! input = {val}, pad0 = {pad0}, pad1 = {pad1}, as int: {full_input}\")             p.sendline(str(full_input))             p.interactive()      Flag:     üß¨ Reversing  üîπ flag_checker    Description:   Attachments: flag_checker   Solution Steps:   main int __fastcall main(int argc, const char **argv, const char **envp) {   _BYTE v4[40]; // [rsp+0h] [rbp-30h] BYREF   unsigned __int64 v5; // [rsp+28h] [rbp-8h]    v5 = __readfsqword(0x28u);   get_input((__int64)v4);   if ( (unsigned __int8)check_input((__int64)v4) )   {     puts(\"PRINTING FLAG: \");     print_flag((__int64)v4);   }   return 0; }   __int64 __fastcall get_input(__int64 a1) {   __int64 result; // rax   int i; // [rsp+18h] [rbp-8h]   int j; // [rsp+1Ch] [rbp-4h]    for ( i = 0; i &lt;= 7; ++i )   {     printf(\"&gt; \");     result = __isoc99_scanf(\"%u\", 4LL * i + a1);   }   for ( j = 0; j &lt;= 7; ++j )   {     result = *(_DWORD *)(4LL * j + a1) % 0xFFFFFF2F;     *(_DWORD *)(a1 + 4LL * j) = result;   }   return result; }   __int64 __fastcall check_input(__int64 flag_inputted) {   int i; // [rsp+10h] [rbp-8h]    for ( i = 0; i &lt;= 7; ++i )   {     if ( (unsigned int)F(test_pt[i], *(unsigned int *)(4LL * i + flag_inputted), 4294967087LL) != test_ct[i] )       return 0LL;   }   return 1LL; }   unsigned __int64 __fastcall F(__int64 flag, __int64 ui, __int64 modulo) {   unsigned __int64 i; // [rsp+18h] [rbp-10h]   unsigned __int64 modulo_flag; // [rsp+20h] [rbp-8h]    i = 1LL;   modulo_flag = flag % modulo;   while ( ui &gt; 0 )   {     if ( (ui &amp; 1) != 0 )       i = modulo_flag * i % modulo;     modulo_flag = modulo_flag * modulo_flag % modulo;     ui &gt;&gt;= 1;   }   return i; }   .rodata:0000000000002040 test_pt         dd 577090037, 2444712010, 3639700191, 3445702192, 3280387012 .rodata:0000000000002040                                         ; DATA XREF: check_input+45‚Üëo .rodata:0000000000002054                 dd 271041745, 1095513148, 506456969 .rodata:0000000000002060                 public test_ct .rodata:0000000000002060 ; _DWORD test_ct[8] .rodata:0000000000002060 test_ct         dd 3695492958, 1526668524, 3790189762, 20093842, 2409408810 .rodata:0000000000002060                                         ; DATA XREF: check_input+6F‚Üëo .rodata:0000000000002074                 dd 239453620, 1615481745, 1887562585 .rodata:0000000000002080                 public flag_enc .rodata:0000000000002080 ; unsigned int flag_enc[8] .rodata:0000000000002080 flag_enc        dd 605589777, 4254394693, 463430822, 2146232739, 4230614750 .rodata:0000000000002080                                         ; DATA XREF: print_flag+54‚Üëo .rodata:0000000000002094                 dd 1466883317, 31739036, 1703606160   from sympy.ntheory import discrete_log from sympy import Mod from pwn import * context.log_level = 'debug' def sl(data): \tfor i in data: \t        p.sendline(str(i)) \tp.interactive()  p = process('./flag_checker')  # Constants MOD = 4294967087  test_pt = [     577090037, 2444712010, 3639700191, 3445702192,     3280387012, 271041745, 1095513148, 506456969, ]  test_ct = [     3695492958, 1526668524, 3790189762, 20093842,     2409408810, 239453620, 1615481745, 1887562585, ]  flag_enc = [     605589777, 4254394693, 463430822, 2146232739,     4230614750, 1466883317, 31739036, 1703606160, ]  recovered_inputs = [] print(\"[*] Recovering inputs by solving discrete logs...\") for i in range(8):     base = test_pt[i]     target = test_ct[i]     try:         exp = discrete_log(MOD, target, base)         recovered_inputs.append(exp)         print(f\"input[{i}] = {exp}\")     except Exception as e:         print(f\"[!] Failed to solve for input[{i}]: {e}\")         recovered_inputs.append(None)  sl(recovered_inputs)      Flag: sigpwny{CrackingDiscreteLogs4TheFun/Lols}     üåç OSINT  üîπ Mr. Blue Sky    Description: Mr. Blue Sky is your average go-lucky BlueSky user, but is there something more to his profile? See if you can find anything on his profile This is the introduction to an OSINT suite. While all other OSINT challenges can be performed in any order, I recommend starting here.   Solution Steps:   Flag:     üîπ Park    Description: This picture was taken in a park. Find the name of the park. The flag is the park‚Äôs name it appears on Google Maps. For example, if you think the flag is in Central Park, submit uiuctf{Central Park}.   Solution Steps:       Flag:     üìå Conclusion  General reflection and notes:     Which challenge was the most interesting?   Which category had the most solves?   Key lessons or takeaways from the event?        ‚ÄúCapture The Flag is not just a game. It‚Äôs a journey to mastering cybersecurity.‚Äù #HappyHacking üîê  "
  },
  
  {
    "title": "Getting Started with Capture The Flag (CTF) in Cybersecurity",
    "url": "/posts/ctf/",
    "categories": "ctf",
    "tags": "ctf, ctftime, cybersecurity, hacking, beginner",
    "date": "2022-07-23 14:00:00 +0700",
    "content": "What is CTF?  Capture The Flag (CTF) is a cybersecurity competition where participants solve challenges to find hidden strings called ‚Äúflags‚Äù (e.g., CTF{you_found_me}). It is a fun and educational way to learn about hacking, security vulnerabilities, cryptography, and forensics.    Types of CTF Competitions  CTF competitions usually come in three main formats:  1. Jeopardy-style Participants are given a board of challenges divided into categories like:    Crypto ‚Äì Cryptographic puzzles   Pwn ‚Äì Binary exploitation   Web ‚Äì Web application vulnerabilities   Reverse Engineering ‚Äì Analyze and reverse software   Forensics ‚Äì Investigate data, memory dumps, etc.   Misc ‚Äì Random or fun challenges   Each challenge has a point value based on difficulty. The team with the highest score wins.  2. Attack-Defense Teams are given vulnerable services to protect while trying to exploit those of others. It involves:    Defending your own services   Attacking and stealing flags from opponent services   3. Mixed / Custom Format Some competitions combine both styles or create their own unique challenge format.    Why Join a CTF?  Participating in CTFs has many benefits:    Learn real-world cybersecurity skills   Practice critical thinking and problem-solving   Collaborate with teams and communities   Build an impressive portfolio for cybersecurity careers   Have fun while learning!     Where to Practice CTF Skills  Several platforms provide free and paid CTF practice environments:     Hack The Box   TryHackMe   picoCTF   CTFlearn   Root Me     Tips for Beginners     Start with basic Linux and networking skills   Learn to use common tools like nmap, wireshark, gdb, burpsuite, etc.   Focus on easy challenges first to build confidence   Join communities (Discord, Telegram, Reddit, etc.)   Read writeups from past CTFs to understand how others solved challenges     Conclusion  CTFs are more than just games‚Äîthey‚Äôre one of the best ways to learn cybersecurity through hands-on experience. Whether you‚Äôre a student or a professional, participating in CTFs can sharpen your skills and open new career opportunities.     ‚ÄúCTF is not just a game, it‚Äôs a gateway to real-world cybersecurity.‚Äù     #HappyHacking üîê "
  },
  
  {
    "title": "Hello World",
    "url": "/posts/hello/",
    "categories": "introductions",
    "tags": "intro",
    "date": "2020-07-21 00:00:00 +0700",
    "content": "Introductions Hello World  print(\"hello world\")  "
  }
  
]

